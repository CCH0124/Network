## 8.1 Background
- 明顯的，*記憶體訪問*和*記憶體管理*是現代電腦系統機操作中非常重要的部分。每條指令必須先從記憶體中取出才能執行，且大多數指令都涉及從記憶體中檢索數據或將數據儲存在記憶體中，或兩者都有
- multi-task OS 的出現增加了記憶體管理的複雜性，因為隨著 process 在 CPU 進出的交換，因此它們的代碼和數據必須在記憶體內進出交換，這些都是快速，並且不會干擾任何其他 process
- Shared memory、virtual memory，將記憶體分類為只讀與讀寫的概念以及像是寫時復制分叉之類的概念使問題進一步複雜化

### 8.1.1 Basic Hardware(基本硬體)
- CPU 只能訪問其暫存器和主記憶體
  - 例如，它不能直接訪問硬碟驅動，因此儲存在硬碟驅動上的所有數據必須先轉移到主記憶體芯片中，然後 CPU 才能使用它。
  - 設備驅動程序透過中斷和"記憶體"訪問與其硬體進行通訊，例如：發送簡短指令以將數據從硬碟驅動傳輸到主記憶體中的指定位置。磁碟控制器監視匯流排以獲取此類指令，傳輸數據然後透過另一個中斷通知 CPU 數據在那，但 CPU 從不直接訪問磁碟。
- 對暫存器的記憶體訪問非常快，通常是一個時鐘滴答，並且一個時鐘滴答 CPU 可能執行多個機器指令
- 對主記憶體的記憶體訪問相對較慢，可能需要花費一些時鐘滴答才能完成。如果不是大多數現代 CPU 內置的中間快取記憶體緩存，這將需要 CPU 難以忍受的等待。快取記憶體的基本思想是一次將記憶體塊從主記憶體傳輸到快取，然後一次從快取訪問單個記憶體位置
- 必須限制用戶 process，以便它們只能訪問屬於該特定 process 的記憶體位置
- 對於每個 process，通常使用一個基底暫存器（base register）和一個界限暫存器（limit register）來實現，下兩張圖所示

![](https://i.imgur.com/FCbc0ID.png "Base and Limit Registers")

![](https://i.imgur.com/plYPKLh.png "Hardware Address Protection with Base and Limit Registers")

- 根據這兩個暫存器檢查用戶 process 進行的每次記憶體訪問，如果嘗試在有效範圍之外進行記憶體訪問，則會產生致命錯誤
- 作業系統顯然可以訪問所有現有的記憶體位置，只有 OS 能夠執行於 kernel model 之中，因為這對於將用戶的代碼和數據交換進出記憶體是必需的
- 明顯的，更改基底暫存器和界限暫存器的內容是一項特權動做，僅允許 OS kernel 使用

### 8.1.2 Address Binding(位址連接)


