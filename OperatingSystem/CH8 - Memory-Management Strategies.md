## 8.1 Background
- 明顯的，*記憶體訪問*和*記憶體管理*是現代電腦系統機操作中非常重要的部分。每條指令必須先從記憶體中取出才能執行，且大多數指令都涉及從記憶體中檢索數據或將數據儲存在記憶體中，或兩者都有
- multi-task OS 的出現增加了記憶體管理的複雜性，因為隨著 process 在 CPU 進出的交換，因此它們的代碼和數據必須在記憶體內進出交換，這些都是快速，並且不會干擾任何其他 process
- Shared memory、virtual memory，將記憶體分類為只讀與讀寫的概念以及像是寫時復制分叉之類的概念使問題進一步複雜化

### 8.1.1 Basic Hardware(基本硬體)
- CPU 只能訪問其暫存器和主記憶體
  - 例如，它不能直接訪問硬碟驅動，因此儲存在硬碟驅動上的所有數據必須先轉移到主記憶體芯片中，然後 CPU 才能使用它。
  - 設備驅動程序透過中斷和"記憶體"訪問與其硬體進行通訊，例如：發送簡短指令以將數據從硬碟驅動傳輸到主記憶體中的指定位置。磁碟控制器監視匯流排以獲取此類指令，傳輸數據然後透過另一個中斷通知 CPU 數據在那，但 CPU 從不直接訪問磁碟。
- 對暫存器的記憶體訪問非常快，通常是一個時鐘滴答，並且一個時鐘滴答 CPU 可能執行多個機器指令
- 對主記憶體的記憶體訪問相對較慢，可能需要花費一些時鐘滴答才能完成。如果不是大多數現代 CPU 內置的中間快取記憶體緩存，這將需要 CPU 難以忍受的等待。快取記憶體的基本思想是一次將記憶體塊從主記憶體傳輸到快取，然後一次從快取訪問單個記憶體位置
- 必須限制用戶 process，以便它們只能訪問屬於該特定 process 的記憶體位置
- 對於每個 process，通常使用一個基底暫存器（base register）和一個界限暫存器（limit register）來實現，下兩張圖所示

![](https://i.imgur.com/FCbc0ID.png "Base and Limit Registers")

![](https://i.imgur.com/plYPKLh.png "Hardware Address Protection with Base and Limit Registers")

- 根據這兩個暫存器檢查用戶 process 進行的每次記憶體訪問，如果嘗試在有效範圍之外進行記憶體訪問，則會產生致命錯誤
- 作業系統顯然可以訪問所有現有的記憶體位置，只有 OS 能夠執行於 kernel model 之中，因為這對於將用戶的代碼和數據交換進出記憶體是必需的
- 明顯的，更改基底暫存器和界限暫存器的內容是一項特權動做，僅允許 OS kernel 使用

### 8.1.2 Address Binding(位址連接)
使用者行程通常使用符號名稱（例如 "i"、"count" 和 "averageTemperature"）引用記憶體地址。這些符號名稱必須映射或連接(bind)到實體記憶體地址，這通常分幾個階段進行：
- Compile Time 
  - 如果在編譯時知道程式在實體記憶體中位置，則編譯器可以生成包含實際實體地址的絕對代碼(absolute code)
  - 如果加載地址(起始位置)稍後更改，則必須重新編譯程式。DOS.COM 程序使用編譯時連接(bind)
- Load Time
  - 如果在編譯時不知道要加載程式的位置，則編譯器必須產生*可重定位碼(relocatable code)* ，該代碼引用相對於程式開始的地址
  - 如果該起始地址發生更改，則必須重新加載程序，不能重新編譯
- Execution Time 
  - 如果程式可以在執行過程中在記憶體中四處移動，則連接(bind)必須延遲到執行時間為止。這需要特殊的硬體，並且是大多數現代 OS 所實現的方法

下圖，顯示了連接(bind)過程的各個階段以及每個階段涉及的單元：

![](https://i.imgur.com/Fb2tu3h.png "Multistep Processing of a User Program")

### 8.1.3 Logical Versus Physical Address Space(邏輯位址空間和實體位址空間) 
- CPU 產生的地址是*邏輯位址*，而記憶體硬體實際看到的地址是*實體位址*。
- 在編譯時或加載時綁定的地址具有相同的邏輯和實體位址
- 但是，在執行時創建的位址具有不同的邏輯和實體位址
  - 在這種情況下，邏輯位址也稱為*虛擬位址(virtual address)* ，這兩個術語在文章中可以互換使用
  - 程式使用的所有邏輯位址的集合組成*邏輯位址空間*，而所有相應的實體位址的集合組成*實體地址空間*
- 邏輯位址到實體位址的運行時間，映射由*記憶體管理單元(memory-management unit) MMU* 處理
  - MMU 可以採用多種形式。最簡單的方法之一是對先前描述的基底暫存器方案的修改
  - 基底暫存器現在稱為*重定位暫存器(relocation register)* ，其值被添加到硬體級別的每個記憶體請求中

![](https://i.imgur.com/ibvEVcd.png "Dynamic relocation using a relocation register")

基底值為 14000，則使用者要存取位址 0 時，就會被重新定位到 14000；對 346 位址的存取會被對應到 14346。程式可以建立一個指標指向 346 的位置，將它存在記憶體中、處理他、將它害其他位只做比較，所有都以 346 做處理。

>用戶程式永遠不會看到實體位址。用戶程式完全在邏輯位址空間中工作，並且任何記憶體引用或操作均使用純邏輯位址完成。僅當位址發送到實體記憶體芯片時，才會產生實體記憶體位址。

### 8.1.4 Dynamic Loading
