# 設計原則
###### tags: `Book` `sofaware`
SOLID 原則告訴我們如何將我們的**函式和資料結構安排到類別中**，以及這些類別該要如何關聯。

一個類別只是一個函示和資料的耦合分組。

此原則目標是建立中層級的軟體結構，結構包含：
- 能容忍變化
- 容易理解
- 在許多軟體系統中能夠使用的元件基礎

:::info
中層級是指這些原則是程式設計師在模組層級工作時應用的原則。有助於定義模組和元件內使用的軟體結構類型。
:::

- SRP
    - 軟體系統最佳結構深深受到使用他的組織的社會結構所影響
    - 每個軟體模組只有唯一的一個理由需要改變
- OCP
    - 要使軟體易於更改，必須將其設計成允許透過增加新程式碼來更改這些系統行為，而不更改現有程式碼
- LSP
    - 建置軟體系統必須來自於可互換的部分，這些部分必須遵守允許這部分相互替換的契約
- ISP
    - 建議軟體設計者避免依賴於他們不使用的東西
- DIP
    - 時做策略的高級程式碼不應該依賴於時做細節的低層級程式碼。
    - 細節應該依賴於策略

## SRP
單一職責原則（SRP，Single Responsibility Principle）

一開始寫程式碼都是將同一功能寫在同一類別中...，假設做一個手機的相機功能如：前景深、縮時攝影等。試著想看看，當這兩種相機功能寫到同一類別中，其中要修正前景深一些焦距功能，此時的依賴會有一些不可預期的可能，像是重新編譯前景深時，可能導致縮時攝影的功能突然間不能使用了...。

**一個模組應該只對唯一的一個角色負責**

**如果能夠想到多於一個的動機去改變一個類別，那麼這個類別就具有多於一個的職責**

SRP 主要的目的就要是增強一個類別（class）或是介面（interface）的內聚力。就是不要讓一個介面**耦合（參雜）** 一個以上的責任。


### 書中範例

##### Example1
Modem 數據機中有 dial 撥號、handup 掛斷、send 傳送資料跟 recv 接收資料四種方法

在這個方法中有兩個職責，一個是連接管理(dial、handup)，另一個是資料通訊(send、recv)
```java=
public interface Modem {
	
	public void dial(String phoneNumber);

	public void handup();
	
	public void send(char c);

	public char recv();
}
```
一旦資料通訊或連接管理需要修改時，呼叫到另一部分也跟著需要**修改**或**重新編譯**。也就是有著依賴關係。

應將兩個不同責任拆開，降低編譯的錯誤以及不相互直接影響。
SRP：分開不同角色所依賴的程式碼(separate the code that different actors deoend on)
![](https://i.imgur.com/D0egqZj.png)

### 總結

單一職責原則是關於含是和類別的，但它又以不同的形式出現在兩個層次以上。在元件層次上，它稱為 CCP 原則。在架構層之上，它成為負責建立邊界的變化軸。

## OCP
開放-封閉原則（OCP，Open-Closed Principle）。

**一個軟體製品應該對於擴展是開法的，但對於修改是封閉的**

不修改原始程式碼，而是新增模組（使用繼承或介面）

![](https://i.imgur.com/z8rKGTS.png)
一個把手，只需要替換想要的起子（六角、星狀、十字等），而不必更改構造。

怎樣需求的改變卻可以保持相對穩定，從而使得系統可以在第一個版本以後不斷推出新的版本 ? ------ OCP

OCP 是物件導向設計核心

### 總結
目標是使系統易於擴展而不會因為修改而產生較大的影響（降低耦合）。這個目標是透過**系統劃分為元件**，並將這些元件安排到依賴階層中而實現的，這種階層結構能**保護較高層級的原件免受較低層級元件的變更所影響**。

## LSP
Liskov 替換原則（LSP）。

**子類別替換替換掉父類別時（繼承），其功能不受影響。** 但是繼承也會導致耦合度變高，子類別進行 *Override*、*Overload* 等動作都要依照父類別的形式，否則架構上會有影響。因此盡量以**多型**取代繼承。

使用者依賴於定義明確的介面，以及依賴於這些介面的實作可替代性。
##### Example
![](https://i.imgur.com/aq7KpJh.png)
矩形(Rectangle)的長寬是獨立可變，但是正方形(Square)必須是一起改變。
解決方法可能是在 User 端坐 if 處裡。

### IS-A
IS-A 的關係應該要從**行為**來判斷的，所以 Square 不是 Rectangle 物件的行為


### 總結
LSP 可以而且也應該擴展至架構層面。
只簡單的違反可替代性，就會導致系統架構受到大量額外機制的汙染。
## ISP
介面隔離(ISP，Interface Segregation Principle)。

![](https://i.imgur.com/ppA6YiS.png)
假設 User1 只使用 op1，User2 只使用 op2 和 User3 只使用 op3。可發現 User1 的原始碼與 op2 和 op3 有著依賴關係，即便不去呼叫此依賴會導致不必要的重新編譯和部署。
需要使用下圖來解決。
![](https://i.imgur.com/a2UIMEa.png)

### ISP 與架構
如果依賴的模組包含了超過你所需要的，那就是有害的。因為要降低不必要的依賴，否則可能導致不必要的編譯與部署。

### 總結
包包中攜帶了不必要的東西，而你卻依賴這樣的包包，就可能會導致你未曾想果的麻煩。

## DIP
依賴反向原則(DIP，Dependency Inversion Principle)。
**原始碼的依賴關係指涉及抽象不涉及具體。**
避免依賴是系統中**容易變化**的具體元素。

### 穩定的抽象
每一個抽象介面的改變都對應到它的具體實作的改變。

- 不要參考易變的具體類別
    - 取而代之的就是使用**抽象**
    - 通常強制使用**抽象工廠模式**
- 不要從易變的具體類別衍生
    - 繼承不是一個問題，是一種依賴
- 不要改寫具體函式
    - 當使用 override 這些函式時，並不會消除依賴關係
    - 為了管理依賴，應該使這個函式式抽象的並建立多個實例
- 永遠不要提到任何具體和易變的名稱

:::warning
原始碼依賴性與控制流程式相反的，這就是依賴反向原則
:::

### 總結
依賴關係在一個方向上穿越過這條曲線，並且此方向將出現越來越抽象的實體，這樣的方式將成為一條新規則，我將稱之為**依賴規則**



## 參考
[medium](https://medium.com/@f40507777/%E6%88%91%E8%A9%B2%E5%AD%B8%E6%9C%83solid%E5%97%8E-4e73887c9156)
