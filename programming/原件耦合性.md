# 原件耦合性
###### tags: `Book` `sofaware`

處裡**原件之間關係**。

## Acyclic Dependancies Principles(ADP) 無環依賴原則
:::info
在元件的依賴關係圖中不允許出現環。
:::
一個團隊再做一個專案時，今天完成了某項功能，不料第二天上班發現此功能壞了。原因可能是有人更改了此功能的依賴項目。

開發人員的工作往往取決於其他開發人員的工作。當整合他們的工作時，它是一團糟。構建經常被打破。一個解決方案是每週構建，但隨著項目的增長，這會遇到問題，因為它開始花費更長時間來集成和部署。
### 消除依賴環
將開發環境劃分成**可發佈的原件**可解決上述問題。這些原件可以做為工作單元，由單一開發者或一個開發團隊來負責完成。就是將原件劃分並各自開發，當完成一個元件時，就將它帶著版本號發佈給其他開發員使用。

要使其達到此目標並能夠工作，就必須對員件的依賴結構進行**管理**。**元件的依賴結構中不能出現環**。出現的話可能會發生一開始講的事件。
### 解除依賴環
- 可以透過依賴倒置原則（DIP）打破循環
- 建立新元件

### 自上而下的設計
無法從上到下設計元件的結構。元件依賴關係圖與描述函數幾乎沒有關係。相反的，元件的依賴關係圖其實是應用程式**可構建性**和**可維護性**。依賴結構隨著系統的設計而增長。因此必須關注 SRP 和 CCP，把可能會一起變化的類別放置一起。



## Stable Dependencies Principle (SDP) 穩定依賴原則
:::info
朝著穩定的方向進行依賴
:::
元件預期是可變的，就不應該讓一個難以更改的元件依賴它。否則，可變元件同樣會難以更改。在 CCP 共同封閉原則可以將這些元件進行分類。

透過遵循 SDP，我們可以確保那些打算易於更改的模組，不會被那些比它們難以更改的模組所依賴。

### 穩定性
穩定性和更改所需要的工作量有關。

![](https://i.imgur.com/RD2Sb3o.png)
這邊顯示了穩定元件 `X`，得知 3 個元件依賴 X，三個理由不改變 X。因此 X 對這三個元件**負有責任**。相反 X 元件不依賴於任何元件，因此外部並不會影響 X 元件。可以稱 X 是`無依賴性的`。

![](https://i.imgur.com/aVlQfP8.png)
這邊是一個非常不穩定的元件。無任何的元件依賴 Y 元件因此 Y 元件是**不承擔責任**。Y 元件反而依賴其它 3 個元件，有著 3 個外部更改理由。可以稱 Y 是依賴性的。

### 計算穩定性的度量
計算*進* *出*該元件的依賴關係的數量，就是計算**位置穩定性**。

- Fan-in
    - 輸入依賴度
    - 這度量代表有多少類別是處於該元件的外部，並依賴於該元件內的類別。
- Fan-out
    - 輸出依賴度
    - 這度量代表有多少類別是處於該元件的內部，並依賴於該元件外的類別。
- I
    - 不穩定性
    - I = Fan-in / (Fan-in + Fan-out)
        - 範圍 0 ~ 1
        - I = 0 表示該元件具有最大穩定性
            - 其它元件依賴於該元件（Fan-in > 0），相反的該元件不依賴於其它任何的元件（Fan-out = 0）
            - 負有責任
            - 無依賴性
        - I = 1 表示該元件具有最大不穩定性
            - 沒有任何其它元件依賴於該元件（Fan-in = 0），相反的該元件卻依賴於其它的元件（Fan-out > 0）
            - 不承擔責任
            - 有依賴性

![](https://i.imgur.com/qurcazj.png)
此圖可以知道 
- Class A
    - I = 1 / (0 + 1) = 1
- Class B
    - I = 2 / (2 + 2) = 0.5
- Class C
    - I = 2 / (1 + 2) = 0.66
- Class D
    - I = 1 / (2 + 1) = 0.33
- Class E
    - I = 1 / (1 + 1) = 0.5
- Class F
    - I = 0 / (1 + 0) = 0

SDP 的規定是，一個元件的 I 值應該大於他所依賴的原件的 I 值。也就是說 I 值必須按著依賴的方向而**逐漸減少**。

不穩定性在 D 類和 C 類之間上升(因為 D 依賴於 C，但 0.33 沒有大於 0.66)，因此它違反了SDP。因此要藉由抽象元件來解決。
抽象元件，**不包含任何可執行**的程式碼，但這是一種極為常見的策略。這些抽象元件非常穩定，因此是不穩定元件所依賴的目標。
 
並非所有元件都是穩定的，當一個系統元件都是最穩定的，那麼**該系統是無發更改的**。實際上設計的元件結構，有些要是穩定的，有些則不穩定。

[SDP](http://fredfoc.com/help-i-need-to-refactor-but-where-should-i-start-sdp-to-the-rescue/)
## Stable Abstractions Principle (SAP) 穩定抽象原則
:::info
元件的抽象程度應該與元件的穩定程度一致
:::
將元件的穩定性和抽象聯繫起來（一個穩定的元件應該是抽象的），好可以**擴展**。一個不穩定的元件應該是具體的，因為不穩定使其內部的具體程式碼容易被更改。

SAP 和 SDP 結合再一起形成了對元件的 DIP 原則。
- SDP
    - 依賴應該朝向穩定的方向進行
- SAP
    - 穩定性意味著**抽象性**

### 高層設計的位置
應該將**封裝系統高層設計的軟體**放進穩定元件中（*I = 0*），不穩定元件（*I = 1*）應該包含不穩定的軟體。
封裝系統高層設計的軟體利用 **OCP** 來抽象。

### 計算抽象度量

- $N_c$
    - 元件中類別總數
- $N_a$
    - 元件中抽象類別及介面總數
- $A$
    - 抽象性
    - $A = N_a / N_c$
    - 範圍 0 ~ 1
        - 0 表示沒有任何抽象類別
        - 1 代表元件中只包含抽象類別

![](https://i.imgur.com/3hFPqLt.png)



